Style
	Breakdown of responsibility for constructor and .activate() method.
		Or should there be a .activate method at all? Should I use a different
		pattern for switching?
		Or maybe a create / load split?
		Or maybe we should create the entire structure, and then load and switch as required?

UI
	Non-buttons in NavBar?  E.g. for All checkbox in class picker.
	NavBar layout?  Multiple lines, ordering?
	Put page-flip controls somewhere else?  Note we arguably only need page flip on touch devices, so maybe we don't care.
	Do we want Esc/Enter/</> buttons on PCs?
	* How to detect tablets?
	* Maybe support iOS scroll events for page flip.
    Disable page flip at first and last pages.

Note that import / merge will need to be something of a three-way merge:  the two versions of the record as reported in the conflict, and the version of the record as it exists now.  For A being the existing record on this server and B being the record being imported, the merge operation probably needs to take (A+B) and B as arguments, and merge the version vectors.  It then needs to compare that merged VV with the then-current record, and if it's still newer then bump the VV and store.  If it's not newer - if the existing record has been bumped in the interim - then it needs to return (A+B) with the merged VV, and the new C, for conflict resolution, and repeat.  That might happen almost automatically if DBput starts returning conflict data.  Probably just restart the conflict resolver on that record, with the new records.

Membership number allocation causes the DB to be rewritten.  Even if we do incremental writes, we end up with a record written for each number allocated.

Maybe rethink List "summarize" to take a schema.

Maybe support form navigation using up/down arrows.

The station display needs to be sorted by server.

Need error messages for "your station is configured to print on a printer on a different server".  Whether that will be a real issue will depend on network configuration; if the server is always the same name / IP address then stations will maintain their identity when moved.

What should happen when a station moves from one server to another?  Depends on whether the server has the same name.  If it does, it's the same station.  If not, it's a different station.

For stations and printers, default to showing only those for this server.

AQ list has funky rendering in Firefox.  Probably related to dynamically changing list.

Browser-side errors need to interrupt UI
window.addEventListener('error', function(event) { ... })
window.onerror = function(message, source, lineno, colno, error) { ... }

Make it clearer when an error is a server-side error.

Try with 6+ label printers

What is UI for new members?
	* how does lookup in MASTER fit in?
	* Do anything about looking up existing memberships first?

Menu items should perhaps look more button-y.
Heck, buttons should look more button-y.

Conflict resolver should use edit schema, at least to get order and labels.  Multi-page conflict resolver would be confusing, but we might have to go there.

Import from DBF
    Import from DBF is basically working, with schema translation.
    Can't import directly into a new DB because the server doesn't return "members" in a table list. How to prime?  Maybe client-side init does a no-op DB operation to get the table set up.  Or maybe the selection is based on the client-side list of tables rather than the server-side list.
    Deliver a canned Reg v2 import somehow?  Maybe by delivering a *.json that
    you can import that will bring in an externalImport map?
    Should be able to import from browser upload, rather than from server file.
    Should fields be ignored by default, or lower-cased and imported by default?
    If they are ignored by default, it's a nuisance to have to fill out the import form.
    If they are imported by default, there's no obvious way to *omit* unwanted fields.
    Not that unwanted fields cause any real trouble.  Member Solutions unwanted fields have very verbose names; it would be unfortunate to duplicate them.
    Convert date formats on import.
    File open errors are not reported back to the user.

Import from Member Solutions
    Partial.  Need content cleanup (e.g. "$75.00" => 75, class name, one-line badge name to two-line badge name).
Import from Eventbrite
Import from CSV
    Column oriented, or with headers?  Probably both.
    Header variant sort of works.
    Get numbers to be numbers.
Import from .XLSX?

Maybe need a "zap table" user interface.  Or maybe external import has a "clear first" option.

Does JS - and in particular node.js - intern strings?  If not, we might want to make a point of interning them at DB load time and record update/add time - at least the field names.

Various imports should probably assign membership numbers if they aren't assigned.  Ugh.  That would mean involving the UI, since the server doesn't know about membership numbers.  Or maybe there's a bulk "assign membership numbers to all records without them".

How should an import file be fed into the system?  Options are upload and direct file access. Direct file access is awkward.  Upload has a problem with how to specify the desired import mapping.  Multipart might allow RPC+file upload.  Or one URL component could be the record ID for the mapping record.

Export (DBF?  CSV?)
Export only marked records?  Perhaps by category?

Developer wads

Bulk ops
	Delete
	Modify?
	report

bulk edit - e.g. for all Saturday, set note

Can add/put eval operations replace the special increment method, to let add-member be a single-atomic-ish operation?  But:  an increment or put operator needs to be async, because the DB might not yet be loaded.  (In theory.)

Turn the expression language into a full-ish programming language.
If I ever expand the use of expressions, one of the first things that's going to have to happen is for all of the functions to become async.

General alert/error UI (alert()?  Modal?)

Transaction log - should this be client-side or server-side?
	* Maybe have the database itself be a transaction log, overwriting earlier versions on load.
	** But export would probably be current versions only; otherwise, we'd have to store all previous versions in memory.
	** And would have to sync previous versions too.
	* If transaction log is a regular DB then it'd always be in memory and that might be too much.
	* How would transaction log sync work?  Ordinary mechanisms would work but seem expensive.  But let's see how fast import is.
    * Note that (R)eports (D)uplicates and (L)ist sort on the server side and then pulls all data across, should sort on the client side.

Add timing data to DBMS ops - load, write, import, export.

What logging do we have for REST operations?

Offline operations
    * Should require as-of if offlineRealTime is set
    ** The problem is that there's no page-level / form-level validation.
	* Caution on home page.

Move InputDate to <input type=date>, et cetera.

working(true) is currently triggered by individual operations.  Perhaps all Nav operations should trigger it.  But note that that would mean PageUp/PageDn would need working(false).  But maybe only Nav, PgUp/PgDn, and Base.switchTo.  Oh, and anything that returns to the same page, e.g. aborted printing.  Perhaps working(true) should have some visible indication, though the general theory is that if it ever takes more than a small fraction of a second it's too long.

There is probably a problem if you have more than ten identical memberships;
you can't get to the eleventh.

Lookup by membership number probably doesn't work because I don't think I have the "numbers must be complete words" logic.  Maybe that could be server-side; maybe it would recognize numeric data and do an exact match.

Widgets don't get full focus marking until you use keyboard navigation.  Or something like that.

If you click outside a field in a form, it should force focus to *some* field, so that *some* field always has focus.

Figure out how to get leave-page warning.

Keyboard commands are still kind of iffy.  See comments in Base.

Printer in either real units or % of label, not pixels.

REPORTS
	* Seem to require server-side knowledge of the schema, sigh.
	* Though I should check the practicality of pulling 20K records over into the browser and then pushing them back to the server.  Maybe it's not as bad as I fear.
	* Maybe push across an expression that describes the report?
	* Report by pushing a reporting expression (or expressions) that are executed server-side and print?  Or by pushing a query expression that does connection and tallying and returns the data to the client for the client to format and send back a print request?  Probably both.
	* How to do reports to files?  Tally reports might not be too bad, but what about member lists?  Maybe a half-REST where we push a report expression using JSON-RPC and it streams back a report?  That would be plain text only, but maybe that's OK.
	* Note Node.js PDFkit could generate PDF reports.  Maybe that's the only kind of report; leave the actual printing to AcroRead.  But plain text can be useful for other purposes.
	* So far just pulling across the data and formating into DOM for display and alternate CSS for printing.
    * CSS class for each report (to allow for selected formating of particular items in that report.  Esp ReportTallyByClass.
    * ReportTallyNewByDate - use convention-start date for distinguishing new reg from prereg.

Classes
	* Do we need single-keystroke selection?


transfers - UI, and how to track.  Since membership number is no longer the key, maybe that's the answer.  The transfer-history records would all have the same membership number, but different keys.  This might require specialized search support - or maybe not; maybe you'd be able to look up a transfer-from record just like a normal record.  Special marking in the List and in the Editor, though.

Editor:
	Don't write record if no change.  (Or is this part of DB.put?)
	General validators.
		We have per-field validation.
		Need form-global validation.

Conflict resolver should detect case where there are no differences.

Log:
	parentelem is not implemented
	If Log() is instantiated before <body> loads, we end up with two bodies.
    Maybe look again at my log infrastructure

Maybe have "All" support be a generic feature for List?  It's now a generic feature for DBManager, but maybe it should move down into List.  (But maybe it should really be checkbox-based to allow for different filters - e.g. for printers there's "show printers on all servers" and "show hidden printers".)

Test edit-edit conflicts, make sure you get a reasonable error.  Lead to conflict resolution.
Fix-last vs delete conflict.  (Same as list-delete conflict, I think.)
Test delete-{list,edit} conflicts.

Force global configuration when not configured.
Force server configuration when not configured.
Force station configuration when not configured.

Full screen.  Might need to prompt user to click to approve.  If we have full screen, we might also want a QUIT button that closes the window, so that people don't have to figure out how to de-full-screen.  Or maybe just maximize.  (Can we maximize from JS?)

Push the printer support work upstream.

REST operations don't have a way to return errors.  (REST upload could.  Rest download would be hard.)

REST upload could maybe use MIME multi-part instead of a separate URL, and that would allow mixing an RPC request with a file upload.

Import/Export user interface.  Do we need a minimal-keystroke variant, given that import/export is expected to be far less frequent than it is today?

Consider disabling autocomplete.

In conflict resolver, it would be nice if we could disable the [Resolve] button until all of the fields are resolved.  The missing piece is that NavBar doesn't have a "disable" concept.

Consider using Element.classList instead of Element.className when adding and removing entries.

DBMS

Incrementally write DB, rather than rewriting the entire thing.  Note that you can just add new versions of a record on the end and they'll overwrite the old ones.  Note also that because we keep the DB in memory it doesn't really matter how long it takes to read it.

If writing the DB (either to persist or for export) is asynchronous, it might interleave with changes.  That's OK for most things, but we might write the server membership number and then later write a record created *after* that point.  Perhaps it needs to stay synchronous, or perhaps we need to ensure that we write the server table last, or perhaps we need to decide that it's OK since after all only this server should care and *it* has the current data.

Must ensure that writing isn't interrupted by quitting!

Make writing use rename so that it's not overwriting the old file.

If writing the DB for persistence is asynchronous, we need to ensure that we restart the write if changes occur during it.  For extra credit, abort a write-in-progress and restart.  Or maybe not; a completed write still gets us a snapshot, versus (in theory) maybe never getting it all written out.

If writing the DB for persistence is asynchronous, we need to make sure we don't do it twice at the same time(!).

Server Installation
** Install label printer driver?  Or maybe just short cut to vendor's download page.
** Firewall.
* Client installation
** Join network.
** Shortcuts/autostarts to server web page.  (Note that if the network config stays constant, a single shortcut can work forever.)
** Browser "print" configuration
** Something to point upload/download at an appropriate device?
** Maybe some of that can be semi-self-configuring, by having the server application serve a batch file (or whatever) that will tweak the client config.  Might need/want to configure multiple browsers.

NewConventionWad (and others?) save Mercurial and GIT history, and shouldn't.
NewConventionWad shouldn't save SampleData (and others?)
NewServerWad - maybe CloneThisConventionWad or something like that?
Need an "update the program" wad.  For this convention, or for a selected convention, or generic and you pick on the target?

NewConventionOnThisSystem needs error checking on the mkdir.

All of the setup stuff could probably use more checking on the new directory name.

Home should set page title.

Exactly when should we retrieve the configuration?  Currently on startup, every time you leave Home, and on successfully leaving Global Config.  (It would be sensible to also retrieve it for station and server edits, but is not currently necessary because Home uses only cfg.convention.)  I'm not entirely happy with this yet, because the "deactivate" mechanism used to pick up the configuration when leaving Home isn't satisfying.  Also it seems like we pick it up too much, which might be a scalability problem.

--------------

Blue Sky

Support multiple conventions.

Maybe TLS and certificate authentication for clients?  But then you have to import the server cert on the clients, and you have to somehow get a client cert to the clients.

Make the server ID be configurable, so that you can preconfigure servers and then (re)assign them to existing IDs.  Probably this would take the form of demanding a server ID if one has not been assigned.  (probably not)

Badges
	* Schedule for program participants
	** Requires coordination with Programming for what key to use
	   for the member.

New merged database is a PITA to edit.  Need general-purpose DBMS tools.

Drive member schema largely or completely from a table.

Credit card integration

Receipts.  Note that receipt might need to cover multiple memberships and perhaps upgrades.

---

Features not planned:

	search interface vs last/first/number interface
